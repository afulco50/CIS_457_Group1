<html>
<head>
    <meta charset="UTF-8">
    <title>3D Cube</title>
</head>
<body>

    <script type="module">
        //imports Three.js
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        // Global 3D Variables for add scene, camera, renderer, and world light functions
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(150, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();

        //resize canvas of maze generator to dynamically match broswer window size
        window.addEventListener('resize', () => {
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Global Variables - cube or geometric object
        const geometry = new THREE.BoxGeometry(2, 2, 1);
        const material = new THREE.MeshPhongMaterial({color: 'purple'});
        const playerMaterial = new THREE.MeshPhongMaterial({color: 'yellow'});
        //const cube = new THREE.Mesh(geometry, material);


        // Create a sphere geometry
        //const playerGeometry = new THREE.SphereGeometry(1, 32, 32);

        // Create a material for the sphere
        //const playerMaterial = new THREE.MeshBasicMaterial({
        //  map: new THREE.TextureLoader().load('images/pacman_image.png'),
        //  side: THREE.DoubleSide
        //});
        
        // Main function
        function main() 
        {
            // remove the default canvas on web page (output)
            //document.querySelector('canvas').remove();

            //for testing
            const maze = 
            [
              [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
              [1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1],   //top left of maze
              [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
              [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1],
              [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1],
              [1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1],
              [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
              [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
              [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
              [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1],
              [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
              [1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1],
              [1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1],   //top right of maze
              [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ];

            //sets inital coords for maze generation
            const numColumns = maze[0].length;
            var xcoord = -numColumns + 4;

            //adds eventListener to arrow keys to allow player 
            window.addEventListener('keydown', onKeyDown);
            var playerLocation = new THREE.Vector3(-numColumns + 6, -2, 0);
            const playerCube = new THREE.Mesh(geometry, playerMaterial);

            //establish player's inital spot in the maze array as a 3D vector
            //var playerLocationInMaze = new THREE.Vector3(1, maze[0].length - 2, 0);
            var playerLocationInMaze = new THREE.Vector3(1, 1, 0);

            //adjust the playerLocation vector according to the arrow keys being clicked
            function onKeyDown(event) 
            {
              //prevents default function of arrow keys (scrolling the page)
              event.preventDefault();
              
              //cases of which arrow key was pressed
              switch (event.key) 
              {
                case 'ArrowUp':
                  //console.log(`Up --> Maze index is ${playerLocationInMaze.y + 1}`);
                  //console.log(`Up --> Other  index is ${playerLocation.y + 1}`);
                  if(maze[playerLocationInMaze.x][playerLocationInMaze.y + 1] == 0) 
                  //&& (playerLocation.y + 1) <= maze[0].length - 1)
                  {
                    //console.log(`Inside Up If`);
                    playerLocation.y += 2;
                    playerLocationInMaze.y += 1;
                  }
                  playerCube.position.set(playerLocation);
                  buildMaze();
                  renderer.render(scene, camera);
                  break;
                case 'ArrowDown':
                  //console.log(`Down --> Maze index is ${playerLocationInMaze.y - 1}`);
                  //console.log(`Down --> Other  index is ${playerLocation.y - 1}`);
                  if(maze[playerLocationInMaze.x][playerLocationInMaze.y - 1] == 0) 
                  //&& (playerLocation.y - 1) >= 1)
                  {
                    //console.log(`Inside Down If`);
                    playerLocation.y -= 2;
                    playerLocationInMaze.y -= 1;
                  }
                  playerCube.position.set(playerLocation);
                  buildMaze();
                  renderer.render(scene, camera);
                  break;
                case 'ArrowLeft':
                  //console.log(`Left --> Maze index is ${playerLocationInMaze.x - 1}`);
                  //console.log(`Left --> Other  index is ${playerLocation.x - 1}`);
                  if(maze[playerLocationInMaze.x - 1][playerLocationInMaze.y] == 0) 
                  //&& (playerLocation.x - 2) >= 0)
                  {
                      //console.log(`Inside Left If`);
                      playerLocation.x -= 2;
                      playerLocationInMaze.x -= 1;
                  }
                  playerCube.position.set(playerLocation);
                  buildMaze();
                  renderer.render(scene, camera);
                  break;
                case 'ArrowRight':
                  //console.log(`Right --> Maze index is ${playerLocationInMaze.y + 1}`);
                  //console.log(`Right --> Other  index is ${playerLocation.y + 1}`);
                  if(maze[playerLocationInMaze.x + 1][playerLocationInMaze.y] == 0) 
                  //&& (playerLocation.x + 2) <= maze.length)
                  {
                      //console.log(`Inside Right If`);
                      playerLocation.x += 2;
                      playerLocationInMaze.x += 1;
                  }
                  playerCube.position.set(playerLocation);
                  buildMaze();
                  renderer.render(scene, camera);
                  //main();
                  break;
              }
            }

            function render() 
            {
                requestAnimationFrame(render);

                // Update camera position based on velocity
                camera.position.add(playerLocation);

                renderer.render(scene, camera);
            }


            // add scene background color, set rendering size,
            // and add to DOM on web page (output)
            scene.background = new THREE.Color('#161718');
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // reposition or transform camera
            //camera.position.set(0, 0, 5);
            camera.position.set(5, 7, 7);

            // create world light and add to scene
            const light = new THREE.HemisphereLight('#FFFFFF', '#757575', 1.7);
            scene.add(light);

            //iterates over 2D array to generate initial maze layout
            function buildMaze(){
            for (let i = 0; i < maze.length; i++) 
            {
                //iterates through all items in that column and generates cubes where needed
                for (let j = 0; j < maze[i].length; j++) 
                {
                    //maze block detected
                    if (maze[i][j] === 1) 
                    {
                        //create a cube at the given indices coordinates
                        const wallCube = new THREE.Mesh(geometry, material);
                        wallCube.position.set(xcoord, -4 + (j * 2), 0);
                        scene.add(wallCube);

                        //console.log(`Cube placed at (${xcoord}, 0, ${-4+(j*2)})`);
                    }
                    else //space is open
                    {
                        //creates cube to represent player location in the maze
                        if(xcoord == playerLocation.x && (-4 + (j * 2)) == playerLocation.y)
                        {
                            playerCube.position.set(xcoord, -4 + (j * 2), 0);
                            scene.add(playerCube);
                        }
                    }
                }

                //increments xcoord 2 units (moving right)
                xcoord += 2;
            }
            xcoord = -numColumns + 4;
}
            buildMaze();
            // render the scene
            renderer.render(scene, camera);
        }

        // call the main() function to initiate the scene
        main();
    </script>
</body>
</html>
